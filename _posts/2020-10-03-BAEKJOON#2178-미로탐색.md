---
layout: post
title: BAEKJOON#2178 미로 탐색
subtitle: Python
cover-img: /assets/img/posting/mountain.jpg
thumbnail-img: /assets/img/posting/baekjoonrect.png
share-img: /assets/img/posting/mountain.jpg
tags: [BFS, DFS, BAEKJOON]
comments: true
---

## [미로 탐색](https://www.acmicpc.net/problem/2178)

<br>

### CODE

```python
import sys
from collections import deque

n,m=map(int,input().split())
maze=[]
for _ in range(n):
    tmp=sys.stdin.readline().strip()
    a=[]
    for i in tmp:
        a.append(int(i))
    maze.append(a)
check = list(list(0 for _ in range(m)) for _ in range(n))
check[0][0]=1

bfs=deque([[0,0]]) #너비 탐색을 위한 큐 생성
dx=[-1,0,1,0]
dy=[0,1,0,-1]

while bfs:
    tmp=bfs.popleft()
    if tmp == [n-1,m-1]:
        print(check[-1][-1])
        sys.exit()
    for x,y in zip(dx,dy):
        ax=tmp[0]+x
        by=tmp[1]+y
        if 0<=ax<n and 0<=by<m and check[ax][by]==0 and maze[ax][by]!=0:
            check[ax][by]=check[tmp[0]][tmp[1]]+1
            bfs.append([ax,by])
```

<br>

## [미로 탐색 - 경로]

![Crepe](https://i.imgur.com/oS403v1.jpg)

7\*7 리스트로 입력이 주어지면 경로의 가지수를 출력하는 문제다.

_입력 예시_

```
0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 0 0 1 0 0 0
1 1 0 1 0 1 1
1 1 0 0 0 0 1
1 1 0 1 1 0 0
1 0 0 0 0 0 0
```

윗 문제에서는 출발지로 부터 도착지 까지 거쳐야 하는 최소의 칸 수를 출력했다면, 이 문제에서는 출발지로 부터 도착지 까지 갈 수 있는 경로의 수를 찾는 문제다.
DFS를 사용해서 풀어보자.

- 먼저 dfs 함수를 만들어 주자.
- 함수의 입력으로 도착지 좌표가 들어오면 'sum'에 +1을 한다.
- 도착지에 도착하지 못했을 경우 양옆과 위아래 중 아직 거치지 않은 칸을 탐색한다.
- 아직 거치지 않은, 갈수 있는 칸이 존재할 경우 그 칸을 0 에서 1로 바꾼 후 dfs함수를 실행시킨다.
- 이렇게 도착지 까지 도달할 수 있는 모든 경우를 구할 수 있다.
  <br>

### CODE

```python
import sys

maze=list(list(map(int,sys.stdin.readline().split())) for _ in range(7))
maze[0][0]=1

dx=[-1,0,1,0]
dy=[0,1,0,-1]
sum=0
def dfs(a,b):
    global sum
    if a==6 and b==6:
        sum+=1
        return
    for x,y in zip(dx,dy):
        if 0<=a+x<7 and 0<=b+y<7 and maze[a+x][b+y]==0:
            maze[a+x][b+y]=1
            dfs(a+x,b+y)
            maze[a+x][b+y]=0

dfs(0,0)
print(sum)
```

<br>
문제를 풀기 전 DFS로 풀어야 할지 BFS로 풀어야 할지 판단을 정확히 하자.

<br>

[다시 풀어보기]
<br>
<br>

---
layout: post
title: BAEKJOON#10830 행렬 제곱
subtitle: Python
cover-img: /assets/img/posting/mountain.jpg
thumbnail-img: /assets/img/posting/baekjoonrect.png
share-img: /assets/img/posting/mountain.jpg
tags: [분할 정복, BAEKJOON, 행렬]
comments: true
---

## [행렬 제곱](https://www.acmicpc.net/problem/10830)

### 문제

크기가 N\*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.

### 입력

첫째 줄에 행렬의 크기 N과 B가 주어진다. (2 ≤ N ≤ 5, 1 ≤ B ≤ 100,000,000,000)

둘째 줄부터 N개의 줄에 행렬의 각 원소가 주어진다. 행렬의 각 원소는 1,000보다 작거나 같은 자연수 또는 0이다.

### 출력

첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다.

### 예제 입력

```
3 3
1 2 3
4 5 6
7 8 9
```

### 예제 출력

```
468 576 684
62 305 548
656 34 412
```

![Crepe](https://s3-media3.fl.yelpcdn.com/bphoto/cQ1Yoa75m2yUFFbY2xwuqw/348s.jpg)

이 문제를 풀면서 동적 프로그래밍과 분할 정복이 뭐가 다른지 궁금증이 생겼다. 한번도 깊이 생각해보지 않았던 문제였다.

### 분할 정복 - Divide & Conquer

분할 정복법은 여러 알고리즘의 기본이 되는 해결 방법으로, 기본적으로는 엄청나게 크고 방대한 문제를 조금씩 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 다음 그것들을 다시 합쳐서 해결하자는 개념에서 출발하였다.

- 분할: 문제를 동일한 유형의 여러 하위 문제로 나눈다.
- 정복: 가장 작은 단위의 하위 문제를 해결하여 정복한다.
- 조합: 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합한다.
  [Reference](https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%EB%B2%95)

![Crepe](https://modoocode.com/img/algorithm/2.1.12.png)

### 동적 프로그래밍 - Dynamic Programming

동적 계획법은 "어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는" 방식의 알고리즘을 총칭한다.
특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법이다.

[Reference](https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%EB%B2%95)

![Crepe](https://w.namu.la/s/c72a6f355ce77b072b312cb52dbb116b2b45bb5260ebedf9f79f6b68b0300aeb44ba8ca7bac3cf478a525c4ba6f6e284847b2cbbf61059f7e42ec2ba75250824adc323ce687aa99fb80035ca10866b5e70c2ca01a5836b9a43dd3706339ba72826c22ebee9bdcf1995a4583df346d7c1)

### Code

```python
import sys
n,m=map(int,sys.stdin.readline().split())
list1=[list(map(int,sys.stdin.readline().split())) for _ in range(n)]

tmp=list([0 for _ in range(n)] for _ in range(n))
#입력받은 후 각 항목을 1000으로 나눈다.
for i in range(n):
    for j in range(n):
        tmp[i][j]= list1[i][j]%1000
#행렬을 n 번 곱한 값을 save[n]에 넣어줄 예정.
save=dict()
save[1]=tmp

def fun(n,m):
    if m in save:
        return save[m]
    else:
        lista=fun(n,m//2)
        listb=fun(n,m-m//2)
        tmp=list([0 for _ in range(n)] for _ in range(n))

        for i in range(n):
            for j in range(n):
                tmp[i][j]=0
                for x in range(n):
                    tmp[i][j]+=lista[i][x]*listb[x][j]
                tmp[i][j]%=1000

        save[m]=tmp
        return save[m]
#출력
for x in fun(n,m):
    for i in x:
        print(i,end=' ')
    print()
```

<br>

## Improved

다른 블로그에서 B를 이진수로 변환시켜 푸는 코드를 발견해 가져와 보았다.
[Reference - blog](https://claude-u.tistory.com/421)

### Code

```python
#행렬 곱셈 함수
def matrix_mul(a, b):
    result = [[0]* N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            for k in range(N):
                result[i][j] += a[i][k] * b[k][j]

    for i in range(N):
        for j in range(N):
            result[i][j] %= 1000

    return result


#2진법으로 변환하여 분할정복 실행
N, B = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(N)]
B = bin(B)[2:] #2진법으로 변환

#단위 행렬
identity_matrix = [[1 if i == j else 0 for i in range(N)] for j in range(N)]

#2진법 자릿수 만큼 제곱 & 제곱한 행렬 끼리 곱해줌
result = identity_matrix[:]
for i in range(len(B)):
    if B[-i-1] == '1':
        temp = matrix[:]
        while i != 0:
            temp = matrix_mul(temp, temp)
            i -= 1
        result = matrix_mul(result, temp)

for row in result:
    print(*row)
```

<br>
<br>

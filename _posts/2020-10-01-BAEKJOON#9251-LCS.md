---
layout: post
title: BAEKJOON#9251,#9252 LCS
subtitle: Python
cover-img: /assets/img/posting/mountain.jpg
thumbnail-img: /assets/img/posting/baekjoonrect.png
share-img: /assets/img/posting/mountain.jpg
tags: [DP, BAEKJOON]
comments: true
---

## [LCS](https://www.acmicpc.net/problem/9251)

두 수열이 주어졌을 때 그들의 부분 수열 중 가장 긴 수열을 찾는 문제다.
이 문제 역시 DP를 이용해 푸는 유형이다.

처음에 DP유형인 것을 알고 풀기 시작했지만 풀어내는데 꽤 긴 시간이 걸렸다.

값을 저장할 이차원 배열을 만든 후 차례차례 값을 집어 넣으며 가장 긴 길이의 수열을 구한다.
입력 예시를 이용해 이해해보자.

_예제 입력_

```
ACAYKP
CAPCAK
```

다음과 같은 입력은 아래와 같은 이차원 배열로 나타낼 수 있다.

| 0 | 'A' | 'C' | 'A' | 'Y' | 'K' | 'P' |
| 'C' | 0 | C | C | C | C | C |
| 'A' | A | C | AC | AC | AC | AC |
| 'P' | A | C | AC | AC | AC | ACP |
| 'C' | A | AC | AC | AC | AC | ACP |  
| 'A' | A | AC | ACA | ACA | ACA | ACP |  
| 'K' | A | AC | ACA | ACA | ACAK | ACAK |

먼저 CAPCAK의 C부터 ACAYKP를 탐색하게 된다.

- C와 A는 중복되는 단어가 없음으로 0
- C와 AC는 C
- C와 ACA는 C
- 나머지 단어들도 마찬가지로 C가 입력된다.

다음으로 A를 살펴보자

-

```
AGGTAB
GXTXAYB
```

```python
import sys
import heapq
a = input()
b = input()
a = '0'+a
b = '0'+b
dp = list([0]*(len(a)) for _ in range(len(b)))

for i in range(1, len(b)):
    tmp = 0
    for j in range(1, len(a)):
        dp[i][j] = dp[i-1][j]
        if b[i] == a[j]:
            tmp = dp[i-1][j-1]+1
        if tmp <= j+1 and dp[i][j] < tmp:
            dp[i][j] = tmp
print(max(dp[-1]))
```

```python
import sys
import heapq
a = input()
b = input()
a = '0'+a
b = '0'+b
dp = list(['']*(len(a)) for _ in range(len(b)))

for i in range(1, len(b)):
    tmp = ''
    for j in range(1, len(a)):
        dp[i][j] = dp[i-1][j]
        if b[i] == a[j]:
            tmp = dp[i-1][j-1]+b[i]
        if len(tmp) <= j+1 and len(dp[i][j]) < len(tmp):
            dp[i][j] = tmp

lcs = dp[-1][-1]
print(len(lcs))
if len(lcs) != 0:
    print(lcs)
```

### DP 대표 유형

- Knapsack Problem (완료)
- Longest Common Sequence
- [Longest Increasing Subsequence](https://youseop.github.io/2020-09-29-BAEKJOON-DP.1-LIS/) (완료)
- Edit distance
- Matrix Chain Multiplication

[다시 풀어보기]
<br>
<br>

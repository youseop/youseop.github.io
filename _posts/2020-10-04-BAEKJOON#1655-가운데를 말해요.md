---
layout: post
title: BAEKJOON#1655 가운데를 말해요
subtitle: Python
cover-img: /assets/img/posting/mountain.jpg
thumbnail-img: /assets/img/posting/baekjoonrect.png
share-img: /assets/img/posting/mountain.jpg
tags: [Heap, BAEKJOON]
comments: true
---

## [가운데를 말해요](https://www.acmicpc.net/problem/1655)

숫자들이 차례로 쌓여감에 따라 숫자들의 중간값을 출력하는 문제다.

리스트를 만들어 숫자들을 집어넣고 매번 정렬을 해 중간값을 찾게 되면 시간 복잡도가 급격히 증가한다. (이 문제에서 주어지는 정수의 최대 개수는 100,000개 이다.)

따라서 heap을 사용해 숫자를 정렬해주어야 한다. 또한, heap은 최소값만 보장해주기 때문에 최소heap, 최대heap을 만들어 사용해야 한다.
아래 그림을 보며 이해해보자!

![Crepe](https://i.imgur.com/0HW8Mjx.jpg)

<br>

### CODE

```python
import sys
import heapq
n = int(input())
up = []
down = []

for _ in range(n):
    num = int(sys.stdin.readline())
    if not down:
        heapq.heappush(down, -num)
    else:
        if -down[0] >= num:
            heapq.heappush(down, -num)
        else:
            heapq.heappush(up, num)
    if len(down)-len(up) == 2:
        tmp = -heapq.heappop(down)
        heapq.heappush(up, tmp)
    elif len(down) < len(up):
        tmp = -heapq.heappop(up)
        heapq.heappush(down, tmp)

    print(-down[0])

```

<br>

### CODE

```python
import sys
import heapq

for _ in range(int(input())):
    k=int(input())
    ids=list(sys.stdin.readline().split() for _ in range(k))
    for i in range(len(ids)):
        ids[i][1]=int(ids[i][1])

    min_hq=[]
    max_hq=[]
    key=[False]*1000001

    for index,id in enumerate(ids):
        if id[0]=='I':
            heapq.heappush( min_hq, (id[1],index))
            heapq.heappush( max_hq, (-id[1],index))
            key[index]=True

        elif id[1]==-1:
            while min_hq and not key[min_hq[0][1]]:
                heapq.heappop(min_hq)
            if min_hq:
                key[heapq.heappop(min_hq)[1]]=False


        elif id[1]==1:
            while max_hq and not key[max_hq[0][1]]:
                heapq.heappop(max_hq)
            if max_hq:
                key[heapq.heappop(max_hq)[1]]=False


    while min_hq:
        if not key[min_hq[0][1]]:
            heapq.heappop(min_hq)
        else: break

    while max_hq:
        if not key[max_hq[0][1]]:
            heapq.heappop(max_hq)
        else: break

    if not min_hq or not max_hq: print('EMPTY')
    else:
        print(-heapq.heappop(max_hq)[0], heapq.heappop(min_hq)[0])
```

<br>
문제를 풀기 전 DFS로 풀어야 할지 BFS로 풀어야 할지 판단을 정확히 하자.

<br>

[다시 풀어보기]
<br>
<br>
